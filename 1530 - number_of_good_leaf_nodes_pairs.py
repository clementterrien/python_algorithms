# This is a problem given by Leetcode.com
# https://leetcode.com/problems/number-of-good-leaf-nodes-pairs/description/

from typing import Any, Optional, Sequence
from unittest import TestCase, main


# Used to implement the expected behaviour
class TreeNode:
    """ This represents a Binary Tree Node."""

    def __init__(self, val: int = 0, left: Optional["TreeNode"] = None, right: Optional["TreeNode"] = None) -> None:
        self.val = val
        self.left = left
        self.right = right

    def create_tree(self, root: Sequence[Optional[int]]) -> "TreeNode":
        """ Create a binary tree from a list representing level-order traversal.
        """
        if not isinstance(root[0], int):
            raise ValueError('The first value of the sequence must be an int to buidl the binary')
        if not root:
            return self

        root_node = self
        root_node.val = root[0]

        queue = [root_node]
        index = 1

        while queue and index < len(root):
            node = queue.pop(0)

            # Set the left child
            if index < len(root) and root[index] is not None:
                left_val = root[index]
                assert isinstance(left_val, int)
                node.left = TreeNode(val=left_val)
                queue.append(node.left)

            index += 1

            # Set the right child
            if index < len(root) and root[index] is not None:
                right_val = root[index]
                assert isinstance(right_val, int)
                node.right = TreeNode(val=right_val)
                queue.append(node.right)

            index += 1

        return root_node

    def __iter__(self):
        """ In-order traversal of the binary tree.
            Yields:
                int: The next value in the in-order traversal of the tree.
        """
        if self.left:
            yield from iter(self.left)
        yield self.val
        if self.right:
            yield from iter(self.right)


N_NODES_LIMIT: int = 2**10
NODE_VAL_LIMIT: int = 100
DISTANCE_LIMIT: int = 10


class Solution:
    """ You are given the root of a binary tree and an integer distance.
        A pair of two different leaf nodes of a binary tree is said to be good if the length of the shortest path
        between them is less than or equal to distance.

        Constraints:
            - The number of nodes in the tree is in the range [1, 2^10].
            - 1 <= Node.val <= 100
            - 1 <= distance <= 10
    """

    def count_pairs(self, root: Sequence[Optional[int]], distance: int) -> int:
        """ Returns the count of good leaf nodes of a binary tree generated by a given sequence.
            Args:
                root (list[int]): The binary tree sequence
                distance (int): The distance to consider leaf nodes as good.

            Returns:
                int: Return the number of good leaf node pairs in the tree.
        """
        self._validate_count_pairs_args(root, distance)

        root_node = TreeNode()
        self.counts = 0
        root_node.create_tree(root)

        self._dfs(root_node, distance)

        return self.counts

    def _dfs(self, tree_node: Optional[TreeNode], distance: int) -> list[int]:
        """ Perform a depth-first search on the tree to find distances to leaf nodes.

            Args:
                node (TreeNode): The current node in the DFS traversal.

            Returns:
                list[int]: A list of distances from the current node to each leaf node in its subtree.

            The function also updates the count of good leaf node pairs if the sum
            of distances from the left and right subtrees is less than or equal to
            the specified distance.
        """
        if not tree_node:
            return []
        if not tree_node.left and not tree_node.right:
            return [1]

        left = self._dfs(tree_node.left, distance)
        right = self._dfs(tree_node.right, distance)

        for l_index in left:
            for r_index in right:
                if l_index + r_index <= distance:
                    self.counts += 1

        return [n + 1 for n in left + right if n + 1 <= distance]

    def _validate_count_pairs_args(self, root: Sequence[int | None], distance: int) -> bool:
        if len(root) > N_NODES_LIMIT:
            raise ValueError(f"The number of nodes exeeds the limit of {N_NODES_LIMIT} nodes.")
        if distance < 1 or distance > DISTANCE_LIMIT:
            raise ValueError("The distance must be a positive integer between 1 and 10 included.")
        if not all([x <= NODE_VAL_LIMIT for x in root if isinstance(x, int)]):
            raise ValueError(f"The Tree node contains node with value which exeeds the limit of :{NODE_VAL_LIMIT}.")

        return True


class TestTreeNode(TestCase):

    def setUp(self) -> None:
        self.solution = Solution()
        self.root_node = TreeNode()

    def check_node(self, node: Any, val: int, left: bool, right: bool) -> TreeNode:
        assert isinstance(node, TreeNode)
        self.assertEqual(node.val, val)

        if left:
            self.assertIsInstance(node.left, TreeNode)
        else:
            self.assertIsNone(node.left)

        if right:
            self.assertIsInstance(node.right, TreeNode)
        else:
            self.assertIsNone(node.right)

        return node

    def test_create_tree_case_1(self) -> None:
        root: list[Optional[int]] = [1, 2, 3, None, 4]
        tree: TreeNode = self.root_node.create_tree(root)

        # root (1)
        tree = self.check_node(tree, 1, True, True)
        # left (2)
        left_child = self.check_node(tree.left, 2, False, True)
        # right (3)
        _ = self.check_node(tree.right, 3, False, False)
        # left_right
        _ = self.check_node(left_child.right, 4, False, False)

    def test_create_tree_case_2(self) -> None:
        root: list[int] = [1, 2, 3, 4, 5, 6, 7]
        tree = self.root_node.create_tree(root)

        # root (1)
        tree = self.check_node(tree, 1, True, True)
        # root left (2)
        tree_left = self.check_node(tree.left, 2, True, True)
        # tree right (3)
        tree_right = self.check_node(tree.right, 3, True, True)
        # root left left (4)
        _ = self.check_node(tree_left.left, 4, False, False)
        # root left right (5)
        _ = self.check_node(tree_left.right, 5, False, False)
        # root right left (6)
        _ = self.check_node(tree_right.left, 6, False, False)
        # root right right (7)
        _ = self.check_node(tree_right.right, 7, False, False)


class TestSolution(TestCase):

    def setUp(self) -> None:
        self.solution = Solution()

    def test_count_pairs_case_0(self) -> None:
        root: list[int] = [1, 2, 3]
        self.assertEqual(self.solution.count_pairs(root, distance=2), 1)
        self.assertEqual(self.solution.count_pairs(root, distance=1), 0)

    def test_count_pairs_case_1(self) -> None:
        root: Sequence[int | None] = [1, 2, 3, None, 4]
        self.assertEqual(self.solution.count_pairs(root, distance=3), 1)
        self.assertEqual(self.solution.count_pairs(root, distance=2), 0)

    def test_count_pairs_case_2(self) -> None:
        root: list[int] = [1, 2, 3, 4, 5, 6, 7]
        self.assertEqual(self.solution.count_pairs(root, distance=3), 2)
        self.assertEqual(self.solution.count_pairs(root, distance=2), 2)
        self.assertEqual(self.solution.count_pairs(root, distance=4), 6)


if __name__ == "__main__":
    main()
